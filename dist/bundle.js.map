{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/Common.ts","webpack:///./src/Game.ts","webpack:///./src/Main.ts","webpack:///./src/Tetrominos.ts","webpack:///./src/Tile.ts"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,iCAAU;AACjC,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,mBAAmB,mBAAO,CAAC,yCAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,wCAAwC;AACxC;AACA;AACA,0CAA0C;AAC1C,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C,4BAA4B,uBAAuB;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uDAAuD;AAClG;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;ACxMa;AACb,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,6BAAQ;AAC7B,qCAAqC;AACrC,iDAAiD;AACjD,2DAA2D;AAC3D,8CAA8C;;;;;;;;;;;;;ACNjC;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,iCAAU;AACjC,aAAa,mBAAO,CAAC,6BAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;ACxMa;AACb,8CAA8C,cAAc;AAC5D,eAAe,mBAAO,CAAC,iCAAU;AACjC;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Common = {\r\n    /**\r\n     * A small util function to verify if the provided object is defined or not\r\n     */\r\n    isUndefined: function () {\r\n        var arg = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            arg[_i] = arguments[_i];\r\n        }\r\n        var allIsUndefined = true;\r\n        Array.prototype.forEach.call(arguments, function (variable) {\r\n            if (!allIsUndefined)\r\n                return false;\r\n            allIsUndefined = (typeof variable === 'undefined');\r\n        });\r\n        return allIsUndefined;\r\n    },\r\n    /**\r\n     * Blocks data to be used for creating a Tetromios using tile class\r\n     * width: Width of a tile image in px\r\n     * height: Height of a tile image in px\r\n     * Background: path of Game Background tile\r\n     * blocks: path to diffrent game tiles\r\n     */\r\n    blocks_data: {\r\n        width: 16,\r\n        height: 16,\r\n        background: './res/background.png',\r\n        blocks: {\r\n            block_blue: './res/block_blue.png',\r\n            block_cyan: './res/block_cyan.png',\r\n            block_green: './res/block_green.png',\r\n            block_orange: './res/block_orange.png',\r\n            block_purple: './res/block_purple.png',\r\n            block_red: './res/block_red.png',\r\n            block_yellow: './res/block_yellow.png'\r\n        }\r\n    },\r\n    /**\r\n     * Small util functrion to bind events\r\n     */\r\n    bind: function (element, type, callback) {\r\n        if (element.attachEvent)\r\n            element.attachEvent('on' + type, callback);\r\n        else\r\n            element.addEventListener(type, callback);\r\n    }\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Common_1 = require(\"./Common\");\r\nvar Tile_1 = require(\"./Tile\");\r\nvar Tetrominos_1 = require(\"./Tetrominos\");\r\nvar Game = /** @class */ (function () {\r\n    function Game(container, renderer, width, height, speed) {\r\n        this.speed = 0;\r\n        this.rightBarWidth = 0;\r\n        this.userMoving = false;\r\n        this.maxBlockByX = 0;\r\n        this.maxBlockByY = 0;\r\n        this.stopMovingActiveFigure = false;\r\n        this.figureRotated = false;\r\n        this.containerWidth = 0;\r\n        this.activeFigureStartPosition = { x: 0, y: 0 };\r\n        this.nextFigureStartPosition = { x: 0, y: 0 };\r\n        this.speed = speed > 4 ? 4 : speed;\r\n        this.rightBarWidth = Common_1.Common.blocks_data.width * 6;\r\n        this.activeFigureStartPosition = { x: 0, y: 0 };\r\n        this.nextFigureStartPosition = { x: 0, y: 0 };\r\n        this.userMoving = false;\r\n        this.step = Math.pow(2, speed) / (2 * Common_1.Common.blocks_data.height);\r\n        this.initialStep = this.step;\r\n        this.stopMovingActiveFigure = false;\r\n        this.figureRotated = false;\r\n        this.self = this;\r\n        this.bindEvents.call(this);\r\n        this.containerWidth = (function (width) {\r\n            var w = width, minWidth = Common_1.Common.blocks_data.width * 5, minCountBlocks = ~~(minWidth / Common_1.Common.blocks_data.width), realBlockHere = ~~(w / Common_1.Common.blocks_data.width);\r\n            realBlockHere = realBlockHere < minCountBlocks ? minCountBlocks : realBlockHere;\r\n            return realBlockHere * Common_1.Common.blocks_data.height;\r\n        })(width) + this.rightBarWidth;\r\n        var containerHeight = (function (height) {\r\n            var h = height, minHeight = Common_1.Common.blocks_data.height * 10, minCountBlocks = ~~(minHeight / Common_1.Common.blocks_data.height), realBlockHere = ~~(h / Common_1.Common.blocks_data.height);\r\n            realBlockHere = realBlockHere < minCountBlocks ? minCountBlocks : realBlockHere;\r\n            return realBlockHere * Common_1.Common.blocks_data.height;\r\n        })(height);\r\n        this.maxBlockByX = (this.containerWidth - this.rightBarWidth) / Common_1.Common.blocks_data.width;\r\n        this.maxBlockByY = containerHeight / Common_1.Common.blocks_data.height;\r\n        var stage = container;\r\n        var gameContainer = new PIXI.DisplayObjectContainer();\r\n        gameContainer.position.x = 0;\r\n        gameContainer.position.y = 0;\r\n        var detailContainer = new PIXI.DisplayObjectContainer();\r\n        detailContainer.position.x = this.containerWidth - this.rightBarWidth;\r\n        detailContainer.position.y = 0;\r\n        detailContainer.width = 200;\r\n        stage.addChild(gameContainer);\r\n        stage.addChild(detailContainer);\r\n        var backgroundTexture = PIXI.Texture.fromImage(Common_1.Common.blocks_data.background);\r\n        for (var _i = 0; _i < this.maxBlockByX; _i++) {\r\n            for (var _y = 0; _y < this.maxBlockByY; _y++) {\r\n                var backgroundBlock = new Tile_1.Tile(function () {\r\n                    return new PIXI.Sprite(backgroundTexture);\r\n                });\r\n                backgroundBlock.setPosition(_i, _y);\r\n                backgroundBlock.addToContainer(gameContainer);\r\n            }\r\n        }\r\n        this.bottomFigures = new PIXI.DisplayObjectContainer();\r\n        gameContainer.addChild(this.bottomFigures);\r\n        var activeFigureMoving = function () {\r\n            var _this = this;\r\n            if (this.userMoving)\r\n                return;\r\n            var self = this;\r\n            if (Common_1.Common.isUndefined(this.activeFigure)) {\r\n                if (!Common_1.Common.isUndefined(this.previousFigure))\r\n                    this.previousFigure.blocks.forEach(function (block) {\r\n                        block.addToContainer(_this.bottomFigures);\r\n                        block.figure.position.x = block.figure.getBounds().x;\r\n                        block.figure.position.y = block.figure.getBounds().y;\r\n                    });\r\n                this.firedLines = this.burnLine.call(this); //burn only if created new figure, not every tick\r\n                if (this.nextFigure)\r\n                    this.activeFigure = this.nextFigure.moveToContainer(gameContainer);\r\n                else\r\n                    this.activeFigure = new Tetrominos_1.Tetrominos(gameContainer);\r\n                this.activeFigureStartPosition = {\r\n                    x: ~~((this.containerWidth - this.rightBarWidth) / Common_1.Common.blocks_data.width / 2),\r\n                    y: -1\r\n                };\r\n                this.step = this.initialStep;\r\n                this.activeFigure.setPosition(this.activeFigureStartPosition);\r\n                this.stopMovingActiveFigure = false;\r\n                //To show the next figure in right side\r\n                this.nextFigure = new Tetrominos_1.Tetrominos(detailContainer);\r\n                this.nextFigureStartPosition = {\r\n                    x: this.rightBarWidth / Common_1.Common.blocks_data.width / 2,\r\n                    y: 2\r\n                };\r\n                this.nextFigure.setPosition(this.nextFigureStartPosition);\r\n            }\r\n            else if (this.figureRotated) {\r\n                if (this.activeFigure.intersectWith(this.bottomFigures))\r\n                    this.activeFigure.rotate(270);\r\n                return this.figureRotated = false;\r\n            }\r\n            if (!this.activeFigure.moveDown(self.step, function () {\r\n                var bounds = this.figure.getBounds(), stopBottom = (bounds.y + bounds.height >= containerHeight);\r\n                return stopBottom || self.activeFigure.intersectWith(self.bottomFigures);\r\n            })) {\r\n                var rcx = this.activeFigure.centerCoords.rcx, rcy = this.activeFigure.centerCoords.rcy, fixDeltaX = rcx - rcx % ~~rcx, fixDeltaY = rcy - rcy % ~~rcy;\r\n                this.activeFigure.setPosition(fixDeltaX, fixDeltaY);\r\n                this.previousFigure = this.activeFigure;\r\n                delete this.activeFigure;\r\n            }\r\n            if (this.bottomFigures.children.length) {\r\n                var minFiredOfLined_1 = Math.max.apply(Math, this.firedLines);\r\n                this.bottomFigures.children.forEach(function (block) {\r\n                    var _block = (new Tile_1.Tile).fromDOC(block);\r\n                    if (_block.figure.getBounds().y <= minFiredOfLined_1)\r\n                        _block.setPosition(_block.coords.x, _block.coords.y + _this.firedLines.length);\r\n                });\r\n            }\r\n        };\r\n        function gameOver() {\r\n            return this.bottomFigures.getBounds().y < 0;\r\n        }\r\n        function animate() {\r\n            if (gameOver.call(this) && confirm('Gameover! Are you want to replay?'))\r\n                return location.reload();\r\n            activeFigureMoving.call(this);\r\n            renderer.render(stage);\r\n            requestAnimationFrame(animate.bind(this));\r\n        }\r\n        requestAnimationFrame(animate.bind(this));\r\n    }\r\n    Game.prototype.bindEvents = function () {\r\n        Common_1.Common.bind(window, 'keyup', this.onKeyUp.bind(this));\r\n        Common_1.Common.bind(window, 'keydown', this.onKeyDown.bind(this));\r\n    };\r\n    Game.prototype.onKeyUp = function () {\r\n        this.userMoving = false;\r\n    };\r\n    Game.prototype.onKeyDown = function (event) {\r\n        this.userMoving = true;\r\n        var self = this;\r\n        switch (event.keyCode) {\r\n            case 37:\r\n                this.activeFigure.moveLeft(function () {\r\n                    var aF = this, existLeft = false;\r\n                    self.bottomFigures.children.forEach(function (block) {\r\n                        if (existLeft)\r\n                            return false;\r\n                        var _block = (new Tile_1.Tile).fromDOC(block);\r\n                        if (~~_block.coords.y == ~~aF.coords.y\r\n                            && ~~_block.coords.x == ~~aF.coords.x - aF.centerCoords.cx - 1)\r\n                            existLeft = true;\r\n                    });\r\n                    return existLeft;\r\n                });\r\n                break;\r\n            case 38:\r\n                this.activeFigure.rotate(90);\r\n                this.figureRotated = true;\r\n                break;\r\n            case 39:\r\n                this.activeFigure.moveRight(function () {\r\n                    var aF = this, existRight = false;\r\n                    self.bottomFigures.children.forEach(function (block) {\r\n                        if (existRight)\r\n                            return false;\r\n                        var _block = (new Tile_1.Tile).fromDOC(block);\r\n                        if (~~_block.coords.y == ~~aF.coords.y\r\n                            && ~~_block.coords.x == ~~aF.coords.x - aF.centerCoords.cx + aF.width)\r\n                            existRight = true;\r\n                    });\r\n                    return existRight;\r\n                });\r\n                break;\r\n            case 40:\r\n                this.step = Math.pow(2, this.speed + 1) / Common_1.Common.blocks_data.height;\r\n                break;\r\n        }\r\n    };\r\n    Game.prototype.burnLine = function () {\r\n        var _this = this;\r\n        var bottomFigureBounds = this.bottomFigures.getBounds(), blockToBurn = [], firedLines = [];\r\n        var _y = 0;\r\n        if (bottomFigureBounds.width >= this.containerWidth - this.rightBarWidth) {\r\n            for (_y = bottomFigureBounds.y; _y < bottomFigureBounds.y + bottomFigureBounds.height; _y += 16) {\r\n                this.bottomFigures.children.forEach(function (block) {\r\n                    if (block.getBounds().y == _y)\r\n                        blockToBurn.push(block);\r\n                });\r\n                if (blockToBurn.length == this.maxBlockByX) {\r\n                    firedLines.push(_y);\r\n                    blockToBurn.forEach(function (block) {\r\n                        _this.bottomFigures.removeChild(block);\r\n                    });\r\n                }\r\n                blockToBurn = [];\r\n            }\r\n        }\r\n        return firedLines;\r\n    };\r\n    return Game;\r\n}());\r\nexports.Game = Game;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Game_1 = require(\"./Game\");\r\nvar stage = new PIXI.Stage(0xAAAAAA); //Create PIXI Stage\r\nvar renderer = PIXI.autoDetectRenderer(388, 292); // Create PIXI Renderer\r\ndocument.getElementById('game').appendChild(renderer.view); // Append view to game div\r\nnew Game_1.Game(stage, renderer, 300, 300, 1); // Creating an instance of Game\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Common_1 = require(\"./Common\");\r\nvar Tile_1 = require(\"./Tile\");\r\n/**\r\n * Creates a Tetrominos\r\n */\r\nexports.Tetrominos = function (parentContainer, type, color) {\r\n    //type = 'T-type';\r\n    //color = Common.blocks_data.blocks.block_yellow;\r\n    this.figure = new PIXI.DisplayObjectContainer();\r\n    this.blocks = [];\r\n    this.height = this.figure.height;\r\n    this.width = this.figure.width;\r\n    this.angle = 0;\r\n    this.centerCoords = { rcx: 0, rcy: 0, cx: 0, cy: 0 };\r\n    var self = this, texture;\r\n    // Defines a Tetromonos\r\n    var typesCreateFn = {\r\n        'line type': function () {\r\n            createFigureByMatrix([\r\n                [1, 1, 1, 1]\r\n            ]);\r\n        },\r\n        'block type': function () {\r\n            createFigureByMatrix([\r\n                [1, 1],\r\n                [1, 1]\r\n            ]);\r\n        },\r\n        '7-type': function () {\r\n            createFigureByMatrix([\r\n                [1, 1],\r\n                [0, 1],\r\n                [0, 1]\r\n            ]);\r\n        },\r\n        'reverse 7-type': function () {\r\n            createFigureByMatrix([\r\n                [1, 1],\r\n                [1, 0],\r\n                [1, 0]\r\n            ]);\r\n        },\r\n        'T-type': function () {\r\n            createFigureByMatrix([\r\n                [1, 1, 1],\r\n                [0, 1, 0]\r\n            ]);\r\n        },\r\n        'flash-type': function () {\r\n            createFigureByMatrix([\r\n                [1, 0],\r\n                [1, 1],\r\n                [0, 1]\r\n            ]);\r\n        },\r\n        'reverse flash-type': function () {\r\n            createFigureByMatrix([\r\n                [0, 1],\r\n                [1, 1],\r\n                [1, 0]\r\n            ]);\r\n        }\r\n    };\r\n    this.figureType = type ? type : getRandomFigureType();\r\n    this.figureColor = color ? color : getRandomBlock();\r\n    texture = PIXI.Texture.fromImage(this.figureColor);\r\n    typesCreateFn[this.figureType].call(this);\r\n    this.addToContainer(parentContainer);\r\n    function getRandomBlock() {\r\n        var keys = Object.keys(Common_1.Common.blocks_data.blocks), rnd = ~~(Math.random() * keys.length), selected = keys[rnd];\r\n        return Common_1.Common.blocks_data.blocks[selected];\r\n    }\r\n    function getRandomFigureType() {\r\n        var keys = Object.keys(typesCreateFn), rnd = ~~(Math.random() * keys.length);\r\n        return keys[rnd];\r\n    }\r\n    function createFigureByMatrix(matrix) {\r\n        self.centerCoords.cx = ~~(matrix[0].length / 2);\r\n        self.centerCoords.cy = ~~(matrix.length / 2);\r\n        matrix.forEach(function (vector, Y) {\r\n            vector.forEach(function (item, X) {\r\n                if (item === 0)\r\n                    return;\r\n                var block = new Tile_1.Tile(function () {\r\n                    return new PIXI.Sprite(texture);\r\n                });\r\n                //block.setPosition(X, Y);\r\n                block.setPosition(X - self.centerCoords.cx, Y - self.centerCoords.cy);\r\n                block.addToContainer(self.figure);\r\n                self.blocks.push(block);\r\n            });\r\n        });\r\n        self.height = matrix.length;\r\n        self.width = matrix[0].length;\r\n    }\r\n};\r\nexports.Tetrominos.prototype = new Tile_1.Tile;\r\n/**\r\n * Removes from current container and moves to a new container\r\n */\r\nexports.Tetrominos.prototype.moveToContainer = function (newContainer) {\r\n    this.remove();\r\n    return new exports.Tetrominos(newContainer, this.figureType, this.figureColor);\r\n};\r\n/**\r\n * Sets the position\r\n */\r\nexports.Tetrominos.prototype.setPosition = function (x, y) {\r\n    var _pos = Tile_1.Tile.prototype.setPosition.call(this, x, y);\r\n    this.centerCoords.rcx = _pos.x / Common_1.Common.blocks_data.width;\r\n    this.centerCoords.rcy = _pos.y / Common_1.Common.blocks_data.height;\r\n};\r\nexports.Tetrominos.prototype.getCoords = function () {\r\n    return {\r\n        X1: this.centerCoords.rcx - this.centerCoords.cx,\r\n        X2: this.centerCoords.rcx - this.centerCoords.cx + this.width,\r\n        Y1: this.centerCoords.rcy - this.centerCoords.cy,\r\n        Y2: this.centerCoords.rcy - this.centerCoords.cy + this.height\r\n    };\r\n};\r\n/**\r\n * Rotates the Tetromios\r\n * When figure turned then real coordinates of center (rcx, rcy) stay unchanged\r\n */\r\nexports.Tetrominos.prototype.rotate = function (angle) {\r\n    var _h = this.height, _w = this.width, maxX = this.figure.parent.getBounds().width / Common_1.Common.blocks_data.height;\r\n    this.height = _w;\r\n    this.width = _h;\r\n    this.angle += angle;\r\n    this.figure.rotation += (angle / 90) * Math.PI / 2;\r\n    if (this.width != this.height) {\r\n        switch (this.angle % 360) {\r\n            case 90:\r\n                this.centerCoords.cx = Math.round(this.width / 2);\r\n                this.centerCoords.cy = ~~(this.height / 2);\r\n                break;\r\n            case 180:\r\n                this.centerCoords.cx = Math.round(this.width / 2);\r\n                this.centerCoords.cy = Math.round(this.height / 2);\r\n                break;\r\n            case 270:\r\n                this.centerCoords.cx = ~~(this.width / 2);\r\n                this.centerCoords.cy = Math.round(this.height / 2);\r\n                break;\r\n            default:\r\n                this.centerCoords.cx = ~~(this.width / 2);\r\n                this.centerCoords.cy = ~~(this.height / 2);\r\n        }\r\n    }\r\n    if (this.getCoords().X1 < 0)\r\n        this.setPosition(this.centerCoords.cx, this.centerCoords.rcy);\r\n    if (this.getCoords().X2 > maxX)\r\n        this.setPosition(maxX - this.width + this.centerCoords.cx, this.centerCoords.rcy);\r\n    return this.angle;\r\n};\r\n/**\r\n * Move the Tetrominos to left and returns the result\r\n */\r\nexports.Tetrominos.prototype.moveLeft = function (checkFn) {\r\n    var newX = this.centerCoords.rcx - 1, result = false;\r\n    newX = newX < this.centerCoords.cx ? this.centerCoords.cx : newX;\r\n    if (Common_1.Common.isUndefined(checkFn) || !checkFn.call(this))\r\n        result = this.setPosition(newX, this.centerCoords.rcy);\r\n    return result;\r\n};\r\n/**\r\n * Move the Tetrominos to right and returns the result\r\n */\r\nexports.Tetrominos.prototype.moveRight = function (checkFn) {\r\n    var newX = this.centerCoords.rcx + 1, maxX = this.figure.parent.getBounds().width / Common_1.Common.blocks_data.height - this.width + this.centerCoords.cx, result = false;\r\n    newX = newX > maxX ? maxX : newX;\r\n    if (Common_1.Common.isUndefined(checkFn) || !checkFn.call(this))\r\n        result = this.setPosition(newX, this.centerCoords.rcy);\r\n    return result;\r\n};\r\n/**\r\n * Detects the collision\r\n */\r\nexports.Tetrominos.prototype.intersectWith = function (withFigure, d) {\r\n    var intersect = false;\r\n    if (withFigure.children.length) {\r\n        this.figure.children.forEach(function (activeBlock) {\r\n            if (intersect)\r\n                return false;\r\n            var x1 = Math.round(activeBlock.getBounds().x), y1 = Math.round(activeBlock.getBounds().y);\r\n            withFigure.children.forEach(function (bottomBlock) {\r\n                if (intersect)\r\n                    return false;\r\n                var x2 = Math.round(bottomBlock.getBounds().x), y2 = Math.round(bottomBlock.getBounds().y);\r\n                if (x1 + Common_1.Common.blocks_data.width <= x2 || x2 + Common_1.Common.blocks_data.width <= x1\r\n                    || y1 + Common_1.Common.blocks_data.height < y2 || y2 + Common_1.Common.blocks_data.height < y1)\r\n                    intersect = false;\r\n                else\r\n                    intersect = true;\r\n            });\r\n        });\r\n    }\r\n    return intersect;\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar Common_1 = require(\"./Common\");\r\n/**\r\n * Handels the tile, building blocks for Tetrominos\r\n */\r\nexports.Tile = function (createFn, parentContainer) {\r\n    this.coords = { x: 0, y: 0 };\r\n    if (!Common_1.Common.isUndefined(parentContainer))\r\n        this.addToContainer(parentContainer);\r\n    if (!Common_1.Common.isUndefined(createFn))\r\n        this.figure = createFn.call(this);\r\n};\r\n/**\r\n * Returns a new tile with proper positions already appended\r\n */\r\nexports.Tile.prototype.fromDOC = function (DOC) {\r\n    var _x = DOC.getBounds().x / Common_1.Common.blocks_data.width, _y = DOC.getBounds().y / Common_1.Common.blocks_data.height;\r\n    var newTile = new exports.Tile(function () {\r\n        return DOC;\r\n    });\r\n    newTile.setPosition(_x, _y);\r\n    return newTile;\r\n};\r\n/**\r\n * Sets the position for a tile\r\n * @returns Tile position\r\n */\r\nexports.Tile.prototype.setPosition = function (x, y) {\r\n    if (!Common_1.Common.isUndefined(x)) {\r\n        if (typeof x == \"object\") {\r\n            this.figure.position = {\r\n                x: x.x * Common_1.Common.blocks_data.width,\r\n                y: x.y * Common_1.Common.blocks_data.height\r\n            };\r\n            this.coords = x;\r\n        }\r\n        else {\r\n            if (Common_1.Common.isUndefined(x, y))\r\n                return false;\r\n            this.coords = { x: x, y: y };\r\n            this.figure.position = {\r\n                x: x * Common_1.Common.blocks_data.width,\r\n                y: y * Common_1.Common.blocks_data.height\r\n            };\r\n        }\r\n    }\r\n    return this.figure.position;\r\n};\r\n/**\r\n * Add tile to a given container\r\n * @param parentContainer DisplayObjectContainer where the tile will be appended\r\n */\r\nexports.Tile.prototype.addToContainer = function (parentContainer) {\r\n    if (Common_1.Common.isUndefined(parentContainer))\r\n        return false;\r\n    this.parentContainer = parentContainer;\r\n    return this.parentContainer.addChild(this.figure);\r\n};\r\n/**\r\n * Moves the tile by setting it's position\r\n */\r\nexports.Tile.prototype.moveDown = function (speed, checkFn) {\r\n    if (!Common_1.Common.isUndefined(checkFn) && checkFn.call(this))\r\n        return false;\r\n    this.setPosition(this.coords.x, this.coords.y + speed);\r\n    return true;\r\n};\r\n/**\r\n * Removes a tile from parent container\r\n */\r\nexports.Tile.prototype.remove = function () {\r\n    return this.parentContainer ? this.parentContainer.removeChild(this.figure) : false;\r\n};\r\n/**\r\n * Detects a tile collision with other tile\r\n */\r\nexports.Tile.prototype.intersectWith = function (withFigure) {\r\n    var self = this, intersect = false, x1 = this.figure.getBounds().x, y1 = this.figure.getBounds().y;\r\n    if (withFigure.children.length)\r\n        withFigure.children.forEach(function (bottomBlock) {\r\n            if (intersect || self.figure == bottomBlock)\r\n                return false;\r\n            var x2 = bottomBlock.getBounds().x, y2 = bottomBlock.getBounds().y;\r\n            if (x1 + Common_1.Common.blocks_data.width <= x2 || x2 + Common_1.Common.blocks_data.width <= x1\r\n                || y1 + Common_1.Common.blocks_data.height < y2 || y2 + Common_1.Common.blocks_data.height < y1)\r\n                intersect = false;\r\n            else\r\n                intersect = true;\r\n        });\r\n    return intersect;\r\n};\r\n"],"sourceRoot":""}